import java.io.IOException
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission
import java.util.Base64
import java.util.Locale
import org.spongepowered.configurate.build.SignJarTask

plugins {
    id "net.kyori.indra.publishing"
}

def archiveName = "configurate-${name.toLowerCase(Locale.ROOT)}"
// convention.getPlugin(BasePluginConvention::class).archivesBaseName = archiveName

tasks.withType(Jar).configureEach {
    indraGit.applyVcsInformationToManifest(manifest)
}

if (project.hasProperty("spongeKeyStore")) {
    // We have to replace the default artifact which is a bit ugly
    // https://github.com/gradle/gradle/pull/13650 should make it easier
    def forRelevantOutgoings = { action -> 
        action.resolveStrategy = Closure.DELEGATE_FIRST
        action.delegate = configurations[JavaPlugin.API_ELEMENTS_CONFIGURATION_NAME].outgoing
        action()
        action.delegate = configurations[JavaPlugin.RUNTIME_ELEMENTS_CONFIGURATION_NAME].outgoing
        action()
    }
    def keyStoreProp = (String) project.property("spongeKeyStore")
    def fileTemp = new File(keyStoreProp)
    def keyStoreFile
    if (fileTemp.exists()) {
        keyStoreFile = fileTemp
    } else {
        // Write keystore to a temporary file
        def dest = layout.projectDirectory.file(".gradle/signing-key").asFile
        dest.parentFile.mkdirs()
        dest.createNewFile()
        try {
            Files.setPosixFilePermissions(dest.toPath(), [PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE])
        } catch (IOException ignored) {
            // oh well
        }

        dest.bytes = Base64.getDecoder().decode(keyStoreProp)
        // Delete the temporary file when the runtime exits
        dest.deleteOnExit()
        keyStoreFile = dest
    }

    tasks.matching { it.name == "jar" && it instanceof Jar }.whenTaskAdded {
        def jarTask = (Jar) it
        it.archiveClassifier.set("unsigned")
        def sign = tasks.register("signJar", SignJarTask) {
            dependsOn(jarTask)
            from(zipTree(jarTask.outputs.files.singleFile))
            manifest = jarTask.manifest
            archiveClassifier.set("")
            keyStore.set(keyStoreFile)
            alias.set(project.property("spongeKeyStoreAlias"))
            storePassword.set(project.property("spongeKeyStorePassword"))
        }

        forRelevantOutgoings {
            artifact(sign)
        }

        tasks.assemble {
            dependsOn(sign)
        }
    }

    afterEvaluate {
        // Remove the unsigned artifact from publications
        forRelevantOutgoings {
            artifacts.removeIf { it.classifier == "unsigned" }
        }
    }
}

indra {
    github("SpongePowered", "Configurate") {
        publishing(true) // GH Packages
        ci(true) // GH Actions
    }
    apache2License()

    if (
        project.hasProperty("spongeSnapshotRepo") &&
        project.hasProperty("spongeReleaseRepo")
    ) {
        publishSnapshotsTo("sponge", project.property("spongeSnapshotRepo") as String)
        publishReleasesTo("sponge", project.property("spongeReleaseRepo") as String)
    }

    configurePublications {
        artifactId = archiveName

        pom {
            inceptionYear.set("2014")

            developers {
                developer {
                    name.set("zml")
                    email.set("zml@spongepowered.org")
                }
            }
        }

        // Don't publish version ranges
        versionMapping {
            usage(Usage.JAVA_API) { fromResolutionResult() }
            usage(Usage.JAVA_RUNTIME) { fromResolutionResult() }
        }
    }
}

// Signing, using specified private key file
signing {
    def spongeSigningKey = project.findProperty("spongeSigningKey")
    def spongeSigningPassword = project.findProperty("spongeSigningPassword")
    if (spongeSigningKey != null && spongeSigningPassword != null) {
        def keyFile = file(spongeSigningKey)
        if (keyFile.exists()) {
            useInMemoryPgpKeys(file(spongeSigningKey).getText('UTF-8'), spongeSigningPassword)
        } else {
            useInMemoryPgpKeys(spongeSigningKey, spongeSigningPassword)
        }
    } else {
        signatories = PgpSignatoryProvider() // don't use gpg agent
    }
}

tasks.withType(Sign).configureEach {
    onlyIf {
        !project.hasProperty("skipSigning")
    }
}
